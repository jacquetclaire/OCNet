
R Under development (unstable) (2020-06-04 r78644) -- "Unsuffered Consequences"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> pkgname <- "OCNet"
> source(file.path(R.home("share"), "R", "examples-header.R"))
> options(warn = 1)
> library('OCNet')
> 
> base::assign(".oldSearch", base::search(), pos = 'CheckExEnv')
> base::assign(".old_wd", base::getwd(), pos = 'CheckExEnv')
> cleanEx()
> nameEx("OCN_to_SSN")
> ### * OCN_to_SSN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: OCN_to_SSN
> ### Title: Transform OCN into SSN object
> ### Aliases: OCN_to_SSN
> 
> ### ** Examples
> 
> # transform a 20x20 single-outlet OCN (aggregated at the AG level)
> # into a SSN object and plot it
> OCN <- aggregate_OCN(landscape_OCN(OCN_20), thrA = 4)
> ssn1 <- OCN_to_SSN(OCN, "AG", obsDesign = SSN::poissonDesign(10), 
+ path=paste(tempdir(),"/OCN.ssn", sep = ""), importToR = TRUE)
> plot(ssn1)
> 
> 
> 
> 
> 
> cleanEx()
> nameEx("OCN_to_igraph")
> ### * OCN_to_igraph
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: OCN_to_igraph
> ### Title: Transform OCN into igraph object
> ### Aliases: OCN_to_igraph
> 
> ### ** Examples
> 
> # 1) transform a 20x20 OCN, at the AG level, into a graph object 
> OCN <- aggregate_OCN(landscape_OCN(OCN_20), thrA = 4)
> g <- OCN_to_igraph(OCN, level = "AG")
> plot(g, layout = matrix(c(OCN$AG$X,OCN$AG$Y), ncol = 2, nrow = OCN$AG$nNodes))
> 
> 
> 
> cleanEx()
> nameEx("aggregate_OCN")
> ### * aggregate_OCN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: aggregate_OCN
> ### Title: Aggregate an Optimal Channel Network
> ### Aliases: aggregate_OCN
> 
> ### ** Examples
> 
> # 1) aggregate a 20x20 OCN by imposing thrA = 4
> OCN <- aggregate_OCN(landscape_OCN(OCN_20), thrA = 4)
> 
> 
> 
> 
> cleanEx()
> nameEx("create_OCN")
> ### * create_OCN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: create_OCN
> ### Title: Create an Optimal Channel Network
> ### Aliases: create_OCN
> 
> ### ** Examples
> 
> # 1) creates and displays a single outlet 20x20 OCN with default options
> set.seed(1)
> OCN_a <- create_OCN(20, 20)
> draw_simple_OCN(OCN_a)
> 
> 
> ## Not run: 
> ##D # 3) generate 3 single-outlet OCNs on the same (100x100) domain starting from different 
> ##D # initial states, and show 20 intermediate plots and console updates.
> ##D set.seed(1)
> ##D OCN_V <- create_OCN(100, 100, typeInitialState = "V", showIntermediatePlots = TRUE, 
> ##D 		nUpdates = 20, displayUpdates = 2)
> ##D OCN_T <- create_OCN(100, 100, typeInitialState = "T", showIntermediatePlots = TRUE, 
> ##D 		nUpdates = 20, displayUpdates = 2)
> ##D OCN_I <- create_OCN(100, 100, typeInitialState = "I", showIntermediatePlots = TRUE, 
> ##D 		nUpdates = 20, displayUpdates = 2)
> ## End(Not run)
> 
> ## Not run: 
> ##D # 4) generate a 2-outlet OCN and show intermediate plots. Note that different colors are used 
> ##D # to identify the two networks  (all pixels are colored because thrADraw = 0).
> ##D set.seed(1)
> ##D OCN <- create_OCN(150, 70, nOutlet = 2, outletPos = c(1, 150), outletSide = c("S", "N"),
> ##D 		typeInitialState = "V", periodicBoundaries = TRUE, 
> ##D 		showIntermediatePlots = TRUE, thrADraw = 0)
> ##D # The resulting networks have an irregular contour, and their outlets are located on the contour:
> ##D draw_contour_OCN(landscape_OCN(OCN))
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("create_peano")
> ### * create_peano
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: create_peano
> ### Title: Create Peano network
> ### Aliases: create_peano
> 
> ### ** Examples
> 
> # 1) create a peano network in a 32x32 square,
> # use landscape_OCN, aggregate_OCN functions,
> # and display subcatchment map and map of drainage area
> peano <- create_peano(4)
> peano <- aggregate_OCN(landscape_OCN(peano), thrA = 4)
> old.par <- par(no.readonly = TRUE)
> par(mfrow=c(1,3))
> draw_simple_OCN(peano)
> title("Peano network")
> draw_subcatchments_OCN(peano)
> title("Subcatchments")
> draw_thematic_OCN(peano$RN$A, peano)
> title("Drainage area at RN level")
> par(old.par)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("draw_contour_OCN")
> ### * draw_contour_OCN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw_contour_OCN
> ### Title: Draw Optimal Channel Network with catchment contours
> ### Aliases: draw_contour_OCN
> 
> ### ** Examples
> 
> # 1) draw contour of a 20x20 single-outlet OCN
> # (for single-outlet OCNs without periodic boundaries, the output
> # of draw_contour_OCN is very similar to that of draw_simple_OCN)
> draw_contour_OCN(landscape_OCN(OCN_20), thrADraw = 4)
> 
> ## Not run: 
> ##D # 2a) plot real shape of multiple-outlet OCN created with periodic boundaries
> ##D # add outlets on top of the rivers
> ##D OCN <- landscape_OCN(OCN_300_4out_PB_hot, displayUpdates = 2) # it takes around one minute
> ##D draw_contour_OCN(OCN, drawOutlets = 2)
> ##D 
> ##D # 2b) same as before, but use same color palette for rivers and contours
> ##D draw_contour_OCN(OCN, colPalCont = 0)
> ##D 
> ##D # 2c) draw contours of catchments obtained from an OCN with nOutlet = "All"
> ##D OCN <- landscape_OCN(OCN_400_Allout, displayUpdates = 2) # it takes some minutes
> ##D draw_contour_OCN(OCN)
> ##D 
> ##D # 2d) same as above, but do not plot contours, and plot outlets 
> ##D # with same color palette as rivers
> ##D draw_contour_OCN(OCN, drawContours = FALSE, drawOutlets = TRUE,
> ##D 		colPalOut = 0)
> ##D 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("draw_elev2D_OCN")
> ### * draw_elev2D_OCN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw_elev2D_OCN
> ### Title: Plot 2D map of elevation generated by an OCN
> ### Aliases: draw_elev2D_OCN
> 
> ### ** Examples
> 
> # 1) draw 2D map of a 20x20 OCN with default settings
> draw_elev2D_OCN(landscape_OCN(OCN_20))
> 
> 
> 
> cleanEx()
> nameEx("draw_elev3D_OCN")
> ### * draw_elev3D_OCN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw_elev3D_OCN
> ### Title: Plot 3D map of elevation generated by an OCN
> ### Aliases: draw_elev3D_OCN
> 
> ### ** Examples
> 
> # draw 3D representation of a 20x20 OCN with default options
> draw_elev3D_OCN(landscape_OCN(OCN_20))
> 
> ## Not run: 
> ##D # 1a) draw the 3D representation of the OCN (without displaying the river  
> ##D # and the colorbar) and enhance the aspect ratio of Z coordinates 
> ##D # with respect to the default value (the final result will be ugly):
> ##D OCN <- landscape_OCN(OCN_400_Allout, displayUpdates = 2) # this takes some minutes  
> ##D draw_elev3D_OCN(OCN, expand = 0.2, addColorbar = FALSE, drawRiver = FALSE)
> ##D 
> ##D # 1b) same as above, but operate coarse graining  and modify shade for better aesthetics: 
> ##D draw_elev3D_OCN(OCN, coarseGrain = c(5,5), expand = 0.2, 
> ##D 		shade = 0.25, addColorbar = FALSE, drawRiver = FALSE)
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("draw_elev3Drgl_OCN")
> ### * draw_elev3Drgl_OCN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw_elev3Drgl_OCN
> ### Title: Plot 3D map of elevation generated by an OCN via rgl rendering
> ### Aliases: draw_elev3Drgl_OCN
> 
> ### ** Examples
> 
> ## Not run: 
> ##D draw_elev3Drgl_OCN(landscape_OCN(OCN_20))
> ## End(Not run)
> 
> ## Not run: 
> ##D # 1a) draw the 3D representation of a single catchment within an OCN 
> ##D # generated with nOutlet = "All" and add draw the river on top of it
> ##D OCN <- landscape_OCN(OCN_400_Allout, displayUpdates = 2) # this takes some minutes
> ##D draw_elev3Drgl_OCN(OCN, chooseCM = 983, drawRiver = TRUE)
> ##D 
> ##D # 1b) draw the 3D representation of the largest catchment within the OCN 
> ##D # (here polygon3d may fail at plotting the polygon at zero elevation)   
> ##D draw_elev3Drgl_OCN(OCN, chooseCM = TRUE) 
> ##D 
> ##D # 1c) draw the 3D representation of the whole OCN
> ##D # and enhance the aspect ratio of Z coordinates 
> ##D # with respect to the default value (the final result will be ugly):  
> ##D draw_elev3Drgl_OCN(OCN, aspect = c(1, 1, 0.2))
> ##D 
> ##D # 1d) same as above, but operate coarse graining for better aesthetics: 
> ##D draw_elev3Drgl_OCN(OCN, coarseGrain = c(5,5), aspect = c(1, 1, 0.2))
> ##D 
> ##D # 2) draw the 3D representation of a single catchment of an OCN generated
> ##D # with periodicBoundaries = TRUE
> ##D # (note that the real shape of the catchment is drawn)
> ##D OCN <- landscape_OCN(OCN_300_4out_PB_hot, displayUpdates = 2) # this takes some minutes
> ##D draw_elev3Drgl_OCN(OCN, chooseCM = TRUE) 
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("draw_simple_OCN")
> ### * draw_simple_OCN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw_simple_OCN
> ### Title: Draw an Optimal Channel Network
> ### Aliases: draw_simple_OCN
> 
> ### ** Examples
> 
> # 1a) draw OCN with default settings
> draw_simple_OCN(OCN_250_T)
> # 1b) same as above, but with decreased thrADraw
> draw_simple_OCN(OCN_250_T, thrADraw = 0.001 * OCN_250_T$dimX * OCN_250_T$dimY)
> 
> 
> 
> cleanEx()
> nameEx("draw_subcatchments_OCN")
> ### * draw_subcatchments_OCN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw_subcatchments_OCN
> ### Title: Draw subcatchment map from an Optimal Channel Network
> ### Aliases: draw_subcatchments_OCN
> 
> ### ** Examples
> 
> # 1a) aggregate a 20x20 OCN , use thrA = 5 pixels
> # and draw subcatchments with default color palette
> OCN <- aggregate_OCN(landscape_OCN(OCN_20), thrA = 5)
> draw_subcatchments_OCN(OCN, drawRiver = TRUE)
> 
> # 1b) same as above, but define color palette with a function
> draw_subcatchments_OCN(OCN, drawRiver = TRUE, colPalette = rainbow)
> 
> # 1c) same as above, but define color palette with a vector of colors
> draw_subcatchments_OCN(OCN, drawRiver = TRUE, colPalette = hcl.colors(6, "Dark 3"))
> 
> 
> 
> 
> cleanEx()
> nameEx("draw_thematic_OCN")
> ### * draw_thematic_OCN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: draw_thematic_OCN
> ### Title: Draw thematic map on an Optimal Channel Network
> ### Aliases: draw_thematic_OCN
> 
> ### ** Examples
> 
> # 1a) Six different ways to display contributing area at the AG level
> OCN <- aggregate_OCN(landscape_OCN(OCN_20), thrA = 4)
> old.par <- par(no.readonly = TRUE)
> par(mfrow=c(2,3), oma = c(0, 0, 3, 0))
> draw_thematic_OCN(OCN$AG$A, OCN, colPalette = hcl.colors) 
> title("Continuous levels \n Colors on edges")
> draw_thematic_OCN(OCN$AG$A, OCN, discreteLevels = TRUE,
+ 		colPalette = hcl.colors) 
> title("Discrete, unique levels \n Colors on edges")
> draw_thematic_OCN(OCN$AG$A, OCN, discreteLevels = TRUE, 
+ 		colLevels = c(1, 10, 50, 100, 500), 
+ 		colPalette = hcl.colors) 
> title("Discrete, user-defined levels \n Colors on edges")
> draw_thematic_OCN(OCN$AG$A, OCN, drawNodes = TRUE, 
+ 		colPalette = hcl.colors)
> title("Continuous levels \n Colors on edges")
> draw_thematic_OCN(OCN$AG$A, OCN,  discreteLevels = TRUE, 
+ 		drawNodes = TRUE, colPalette = hcl.colors)
> title("Discrete, unique levels \n Colors on nodes")
> draw_thematic_OCN(OCN$AG$A, OCN, discreteLevels = TRUE, 
+ 		drawNodes = TRUE, colLevels = c(1, 10, 50, 100, 500), 
+ 		colPalette = hcl.colors)
> title("Discrete, user-defined levels \n Colors on nodes")
> mtext("Six different ways to display contributing area [no. pixels]", outer = TRUE, cex = 1.5)
> par(old.par)
> 
> # 1b) Same as above, but use different colLevels, cutoff combinations
> # with DiscreteLevels = FALSE
> old.par <- par(no.readonly = TRUE)
> par(mfrow=c(1,2))
> draw_thematic_OCN(OCN$AG$A, OCN, drawNodes = TRUE,
+ 		 colLevels = c(0, 200, 1000), colPalette = hcl.colors)
> title("All nodes with A > 200 pixels \n are displayed in yellow")
> draw_thematic_OCN(OCN$AG$A, OCN, drawNodes = TRUE, 
+ 		nanColor = "#00000000", colLevels = c(0, 200, 1000),
+ 		cutoff = TRUE, colPalette = hcl.colors)
> title("All nodes with A > 200 pixels \n are treated as NaN")		
> par(old.par)
> 
> ## Not run: 
> ##D # 2) Display distance to outlet (at the RN level) along the main stem
> ##D # of an OCN
> ##D OCN <- aggregate_OCN(landscape_OCN(OCN_250_T)) # this takes some seconds
> ##D OCN <- paths_OCN(OCN, pathsRN = TRUE) # this takes some seconds
> ##D 
> ##D distanceToOutlet <- OCN$RN$downstreamPathLength[,OCN$RN$outlet]
> ##D farthestNode <- which(distanceToOutlet == max(distanceToOutlet))
> ##D mainStem <- OCN$RN$downstreamPath[[farthestNode]][[OCN$RN$outlet]]
> ##D theme <- rep(NaN, OCN$RN$nNodes)
> ##D theme[mainStem] <- distanceToOutlet[mainStem]
> ##D 
> ##D draw_thematic_OCN(theme, OCN)
> ##D title("Distance to outlet along the main stem [pixel units]")
> ## End(Not run)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("find_area_threshold_OCN")
> ### * find_area_threshold_OCN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: find_area_threshold_OCN
> ### Title: Find relationship between number of nodes and threshold area in
> ###   an OCN
> ### Aliases: find_area_threshold_OCN
> 
> ### ** Examples
> 
> # 1) derive relationship between threshold area and number of nodes
> OCN <- landscape_OCN(OCN_20)
> thr <- find_area_threshold_OCN(OCN)
> # log-log plot of number of nodes at the AG level versus 
> # relative threshold area (as fraction of total drainage area) 
> old.par <- par(no.readonly = TRUE)
> par(mai = c(1,1,1,1))  
> plot(thr$thrValues[thr$nNodesAG > 0]/OCN$CM$A,
+ 		thr$nNodesAG[thr$nNodesAG > 0], log = "xy",
+ 		xlab = "Relative area threshold", ylab = "Number of AG nodes")
> par(old.par)
> 
> 
> 
> graphics::par(get("par.postscript", pos = 'CheckExEnv'))
> cleanEx()
> nameEx("landscape_OCN")
> ### * landscape_OCN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: landscape_OCN
> ### Title: Generate 3D landscape from an Optimal Channel Network
> ### Aliases: landscape_OCN
> 
> ### ** Examples
> 
> # 1) draw 2D elevation map of a 20x20 OCN with default options
> OCN2 <- landscape_OCN(OCN_20)
> 
> ## Not run: 
> ##D # 2) generate a 100x50 OCN; assume that the pixel resolution is 200 m
> ##D # (the total catchment area is 20 km2)
> ##D set.seed(1)
> ##D OCN <- create_OCN(100, 50, cellsize = 200, 
> ##D 		displayUpdates = 0) # this takes about 40 s
> ##D # use landscape_OCN to derive the 3D landscape subsumed by the OCN
> ##D # by assuming that the elevation and slope at the outlet are 200 m 
> ##D # and 0.0075, respectively
> ##D OCN <- landscape_OCN(OCN, zMin = 200, slope0 = 0.0075)
> ##D # draw 2D and 3D representations of the landscape
> ##D draw_elev2D_OCN(OCN)
> ##D draw_elev3D_OCN(OCN)
> ##D draw_elev3Drgl_OCN(OCN)
> ## End(Not run)
> 
> ## Not run: 
> ##D # 3) generate a 100x50 OCN with 4 outlets
> ##D set.seed(1)
> ##D OCN <- create_OCN(100, 50, cellsize = 200, 
> ##D 		nOutlet = 4, displayUpdates = 0) # this takes about 40 s
> ##D # use landscape_OCN and optimize elevation of outlets	
> ##D OCN <- landscape_OCN(OCN, slope0 = 0.0075, 
> ##D 		optimizeDZ = TRUE)
> ##D # display elevation of outlets and 2D elevation map
> ##D OCN$FD$Z[OCN$FD$outlet]	
> ##D draw_elev2D_OCN(OCN)	
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("paths_OCN")
> ### * paths_OCN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: paths_OCN
> ### Title: Calculate paths between nodes in an Optimal Channel Network
> ### Aliases: paths_OCN
> 
> ### ** Examples
> 
> # 1) Calculate paths between nodes of an OCN
> OCN <- paths_OCN(aggregate_OCN(landscape_OCN(OCN_20), thrA = 4))
> ## Not run: 
> ##D # 2) Display distance to outlet (at the RN level) along the main stem
> ##D # of an OCN
> ##D OCN <- aggregate_OCN(landscape_OCN(OCN_250_T)) # this takes some seconds
> ##D OCN <- paths_OCN(OCN, pathsRN = TRUE) # this takes some seconds
> ##D 
> ##D distanceToOutlet <- OCN$RN$downstreamPathLength[,OCN$RN$outlet]
> ##D farthestNode <- which(distanceToOutlet == max(distanceToOutlet))
> ##D mainStem <- OCN$RN$downstreamPath[[farthestNode]][[OCN$RN$outlet]]
> ##D theme <- rep(NaN, OCN$RN$nNodes)
> ##D theme[mainStem] <- distanceToOutlet[mainStem]
> ##D 
> ##D draw_thematic_OCN(theme, OCN)
> ##D title("Distance to outlet along the main stem [pixel units]")
> ## End(Not run)
> 
> 
> 
> cleanEx()
> nameEx("rivergeometry_OCN")
> ### * rivergeometry_OCN
> 
> flush(stderr()); flush(stdout())
> 
> ### Name: rivergeometry_OCN
> ### Title: River geometry of an Optimal Channel Network
> ### Aliases: rivergeometry_OCN
> 
> ### ** Examples
> 
> # 1) Compute river geometry of a 20x20 OCN with default options
> # and display river width at the RN level
> OCN <- rivergeometry_OCN(aggregate_OCN(landscape_OCN(OCN_20)))
> draw_thematic_OCN(OCN$RN$width,OCN)
> 
> 
> 
> ### * <FOOTER>
> ###
> cleanEx()
> options(digits = 7L)
> base::cat("Time elapsed: ", proc.time() - base::get("ptime", pos = 'CheckExEnv'),"\n")
Time elapsed:  11.246 0.181 11.44 0 0.008 
> grDevices::dev.off()
null device 
          1 
> ###
> ### Local variables: ***
> ### mode: outline-minor ***
> ### outline-regexp: "\\(> \\)?### [*]+" ***
> ### End: ***
> quit('no')
